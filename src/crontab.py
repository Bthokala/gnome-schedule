# crontab.py - code to interfere with crontab
# Copyright (C) 2004, 2005 Philip Van Hoof <me at freax dot org>
# Copyright (C) 2004, 2005 Gaute Hope <eg at gaute dot eu dot org>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import gtk
import cronconf
import re
import os
import sys
import tempfile

##
## I18N
##
from rhpl.translate import _, N_
import rhpl.translate as translate
domain = 'gnome-schedule'
translate.textdomain (domain)
gtk.glade.bindtextdomain(domain)

class Crontab:
	def __init__(self, parent):
		self.crontabRecordRegex = re.compile('([^\s]+)\s([^\s]+)\s([^\s]+)\s([^\s]+)\s([^\s]+)\s([^#\n$]*)(\s#\s([^\n$]*)|$)')
		self.ParentClass = parent

		#reading crontab
		self.readCrontab()

		return

	def writeCrontab(self):
		tmpfile = tempfile.mkstemp ("", "/tmp/crontab.", "/tmp")
		fd, path = tmpfile
		tmp = os.fdopen(fd, 'w')
		count = 0
		for line in self.lines:

			## Ignore the first three comments:

			## DO NOT EDIT THIS FILE - edit the master and reinstall.
			## (/tmp/crontab.XXXXXX installed on Xxx Xxx  x xx:xx:xx xxxx)
			## (Cron version -- $Id$)

			if count < 3 and len(line) > 1 and line[0] == "#":
				print "Ignored:" + line
			else:
				tmp.write (line)
				if line[len(line)-1] != '\n':
					tmp.write ("\n")
			count = count + 1

		tmp.close ()

		if self.ParentClass.root:
			print "crontab -u " + self.ParentClass.user + " " + path
			os.system ("crontab -u " + self.ParentClass.user + " " + path)
		else:
			print "crontab " + path
			os.system ("crontab " + path)

		os.unlink (path)
		return

	def updateLine (self, linenumber, record):
		self.lines[linenumber] = record
		self.writeCrontab ()

	def deleteLine (self, linenumber):
		number = 0
		newlines = list ()
		for line in self.lines:
			if number != linenumber:
				newlines.append (line)
			else:
				print "remove"
			number = number + 1

		self.lines = newlines
		self.writeCrontab ()

	def appendLine (self, record):
		self.lines.append (record)
		self.writeCrontab ()

	def readCrontab(self):
		if self.ParentClass.root:
			execute = "crontab -l -u " + self.ParentClass.user
		else:
			execute = "crontab -l"

		p = re.compile('^(.*)\s(.*)\s(.*)\s(.*)\s(.*)\s(.*)[\s#\s(.*)|]$')
		self.linecount = 0
		self.lines = os.popen(execute).readlines()
		for line in self.lines:
			array_or_false = self.parseRecord (line)
			if array_or_false != gtk.FALSE:
				(minute, hour, day, month, weekday, command, title) = array_or_false
				time = minute + " " + hour + " " + day + " " + month + " " + weekday
				iter = self.ParentClass.treemodel.append([title, self.easyString (minute, hour, day, month, weekday), command, line, self.linecount, time])
			self.linecount = self.linecount + 1
		return

	def parseRecord (self, line):
		if len (line) > 1 and line[0] != '#':
			m = self.crontabRecordRegex.match(line)
			if m != None:
					print m.groups()
					minute = m.groups ()[0]
					hour = m.groups ()[1]
					day = m.groups ()[2]
					month = m.groups ()[3]
					weekday = m.groups ()[4]
					command = m.groups ()[5]
					title = m.groups ()[7]
					if title == None:
						title = "Untitled"

					return minute, hour, day, month, weekday, command, title
		return gtk.FALSE

	def amountApp (self, amount):
		if amount == "1":
			return _("st.")
		else:
			return _("th.")

	def valToTimeVal (self, val):
		if val == "0" or val == "1" or val == "2" or val == "3" or val == "4" or val == "5" or val == "6" or val == "7" or val == "8" or val == "9":
			return "0" + val
		else:
			return val

	def easyString (self, minute, hour, day, month, weekday):
		if minute == "*" and hour == "*" and month == "*" and day == "*" and weekday == "*":
			return _("Every minute")

		if minute != "*" and hour == "*" and month == "*" and day == "*" and weekday == "*":
			return _("Every ") + minute + self.amountApp (minute) + _(" minute of every hour")

		if hour != "*" and month == "*" and day == "*" and weekday == "*":
			if minute == "0":
				return _("Every ") + hour + self.amountApp (hour) + _(" hour of the day")
			elif minute != "*":
				return _("At ") + hour + ":" + minute + _(" every day")
		
		if month == "*" and day != "*" and weekday == "*":
			if minute == "0" and hour == "0":
				return _("Every ") + day + self.amountApp (day) + " day of the month"
			elif minute != "*" and hour != "*":
				return _("At ") + hour + ":" + minute + _(" every ") + day + self.amountApp (day) + _(" day of the month")


		if month != "*" and weekday == "*":
			if minute == "0" and hour == "0" and day == "1":
				return _("Every ") + month + self.amountApp (month) + _(" month of the year")
			elif minute != "*" and hour != "*" and day != "*":
				return _("At the ") + day + self.amountApp(day) + " " + self.valToTimeVal(hour) + ":" + self.valToTimeVal(minute) + _(" every ") + month + self.amountApp(month) + _(" month of the year")


		if month == "*" and day == "*" and weekday != "*":
			if minute == "0" and hour == "0":
				return _("Every ") + weekday + self.amountApp (weekday) + _(" day of the week")
			elif minute != "*" and hour != "*":
				return _("Every ") + weekday + self.amountApp(weekday) + _(" day of the week at ") + self.valToTimeVal (hour) + ":" + self.valToTimeVal (minute) + ""

		return minute + " " + hour + " " + day + " " + month + " " + weekday
